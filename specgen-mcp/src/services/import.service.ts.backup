import { glob } from 'glob';
import { join } from 'path';
import { existsSync, statSync } from 'fs';
import { SpecParser, ParsedSpec } from '../parsers/spec-parser.js';
import { EnhancedDatabaseConnection } from '../database/enhanced-connection.js';

/**
 * Service for importing SPEC files into the database
 */
export class ImportService {
  /**
   * Import SPEC files from a directory
   */
  static async importFromDirectory(
    directoryPath: string, 
    pattern: string = 'SPEC-*.md',
    options: ImportOptions = {}
  ): Promise<ImportResult> {
    try {
      if (!existsSync(directoryPath)) {
        throw new Error(`Directory does not exist: ${directoryPath}`);
      }

      if (!statSync(directoryPath).isDirectory()) {
        throw new Error(`Path is not a directory: ${directoryPath}`);
      }

      // Find matching files
      const searchPattern = join(directoryPath, '**', pattern);
      const filePaths = await glob(searchPattern, {
        ignore: ['node_modules/**', '.git/**', '**/.specgen/**']
      });

      if (filePaths.length === 0) {
        return {
          success: true,
          message: `No SPEC files found matching pattern: ${pattern}`,
          imported: [],
          errors: [],
          summary: {
            total: 0,
            successful: 0,
            failed: 0,
            skipped: 0,
            byGroup: {},
            byStatus: {}
          }
        };
      }

      // Parse all files
      const parsedSpecs = SpecParser.parseMultipleSpecs(filePaths);
      
      // Import to database
      const importResults = await this.importSpecsToDatabase(parsedSpecs, options);
      
      return {
        success: true,
        message: `Import completed: ${importResults.successful} successful, ${importResults.failed} failed`,
        imported: importResults.imported,
        errors: importResults.errors,
        summary: importResults.summary
      };

    } catch (error) {
      return {
        success: false,
        message: `Import failed: ${error instanceof Error ? error.message : String(error)}`,
        imported: [],
        errors: [error instanceof Error ? error.message : String(error)],
        summary: {
          total: 0,
          successful: 0,
          failed: 0,
          skipped: 0,
          byGroup: {},
          byStatus: {}
        }
      };
    }
  }

  /**
   * Import individual SPEC file
   */
  static async importFile(filePath: string, options: ImportOptions = {}): Promise<ImportResult> {
    try {
      const parsedSpec = SpecParser.parseSpecFile(filePath);
      const results = await this.importSpecsToDatabase([parsedSpec], options);
      
      return {
        success: results.successful > 0,
        message: results.successful > 0 ? 'File imported successfully' : 'File import failed',
        imported: results.imported,
        errors: results.errors,
        summary: results.summary
      };
    } catch (error) {
      return {
        success: false,
        message: `Failed to import file: ${error instanceof Error ? error.message : String(error)}`,
        imported: [],
        errors: [error instanceof Error ? error.message : String(error)],
        summary: {
          total: 1,
          successful: 0,
          failed: 1,
          skipped: 0,
          byGroup: {},
          byStatus: {}
        }
      };
    }
  }

  /**
   * Import parsed specs to database
   */
  private static async importSpecsToDatabase(
    parsedSpecs: ParsedSpec[], 
    options: ImportOptions
  ): Promise<ImportDatabaseResult> {
    const db = EnhancedDatabaseConnection.getCurrentProjectConnection();
    const imported: ImportedSpec[] = [];
    const errors: string[] = [];
    const summary = {
      total: parsedSpecs.length,
      successful: 0,
      failed: 0,
      skipped: 0,
      byGroup: {} as Record<string, number>,
      byStatus: {} as Record<string, number>
    };

    // Prepare statements
    const insertStmt = db.prepare(`
      INSERT INTO specs (title, body_md, status, feature_group)
      VALUES (?, ?, ?, ?)
    `);

    const checkExistingStmt = db.prepare(`
      SELECT id FROM specs WHERE title = ?
    `);

    for (const spec of parsedSpecs) {
      try {
        // Check if spec already exists (unless overwrite is enabled)
        if (!options.overwrite) {
          const existing = checkExistingStmt.get(spec.title);
          if (existing) {
            summary.skipped++;
            errors.push(`Spec "${spec.title}" already exists (use --overwrite to replace)`);
            continue;
          }
        }

        // Insert or replace spec
        const result = insertStmt.run(
          spec.title,
          spec.body_md,
          spec.status,
          spec.feature_group
        );

        imported.push({
          id: result.lastInsertRowid as number,
          title: spec.title,
          status: spec.status,
          feature_group: spec.feature_group,
          source_file: spec.source_file
        });

        summary.successful++;
        
        // Update counters
        summary.byGroup[spec.feature_group] = (summary.byGroup[spec.feature_group] || 0) + 1;
        summary.byStatus[spec.status] = (summary.byStatus[spec.status] || 0) + 1;

      } catch (error) {
        summary.failed++;
        const errorMsg = `Failed to import "${spec.title}": ${error instanceof Error ? error.message : String(error)}`;
        errors.push(errorMsg);
        
        if (options.stopOnError) {
          break;
        }
      }
    }

    return {
      imported,
      errors,
      successful: summary.successful,
      failed: summary.failed,
      summary
    };
  }
}

export interface ImportOptions {
  overwrite?: boolean;
  stopOnError?: boolean;
  dryRun?: boolean;
}

export interface ImportResult {
  success: boolean;
  message: string;
  imported: ImportedSpec[];
  errors: string[];
  summary: ImportSummary;
}

export interface ImportedSpec {
  id: number;
  title: string;
  status: string;
  feature_group: string;
  source_file: string;
}

export interface ImportSummary {
  total: number;
  successful: number;
  failed: number;
  skipped: number;
  byGroup: Record<string, number>;
  byStatus: Record<string, number>;
}

interface ImportDatabaseResult {
  imported: ImportedSpec[];
  errors: string[];
  successful: number;
  failed: number;
  summary: ImportSummary;
}